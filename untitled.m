clc;
clear variables;
%Мой метод.(я Кочетков Александр если что) Через матрицу инцидентности, описывающую цепь без элементов.
%входные данные.     Если узлов нет, то решаем другим методом
R1=200;     %задача из 3 семинара. Ответ сошелся (у меня другое направление токов, поэтому знак другой на некоторых ветвях. направление от меньшего узла к большему(по номеру))
E1=600;          
E3=100i;
C2=-100i;
L2=200i;
C4=-100i;
R5=100;
J5=-2+2i;
L6=100i;
E6=-100i;                     
a=[1 0 0 -1].';            %это матрица инцидентности для графа схемы. 
b=[1 -1 0 0].';            %не работает, если в схеме нет узлов. 
c=[0 1 0 -1].';            %тогда исмользуем закон ома
d=[1 0 -1 0].';
e=[0 1 -1 0].';
f=[0 0 1 -1].';
graf=[a b c d e f];
a1=[R1 0 0 E1 0]';             %здесь входные данные в виде просто 
% транспонированного вектора,
% но если на ветви более одного элемента одного типа, 
% то эти элементы записываются в третьей размерности
b1=[0 0 0 E3 0].';
c1=[R5 0 0 0 J5].';
d1=[0 C2 L2 0 0].';
e1=[0 C4 0 0 0].';
f1=[0 0 L6 E6 0].';
m_element=[a1 b1 c1 d1 e1 f1]; %это матрица элементов на ветвях (сейчас у нее 2 размерности, так как на ветви максимум 1 элемент одного типа)
%конец входных данных
graf_modul=abs(graf);         %это неориентированный граф тот же самый, понадобится тоже
vetvi=size(graf, 2);     %кол-во ветвей
I=zeros(1, vetvi);         %массив токов на ветвях (будущий ответ)
uzli=size(graf, 1);         %кол-во узлов
nn=size(m_element, 3);      %максимальное кол-во элементов одного типа на 
                            % ветви (третья размерность матрицы элементов)
sum_R=zeros(1, vetvi);
for yy=1:vetvi
    for xx=1:3
        for zz=1:nn
        sum_R (yy)=sum_R (yy)+m_element (xx, yy, zz); % массив сум Р теперь состоит 
                                                      % из сумм сопротивлений на ветвях от 1 до последней
        end
    end
end

sum_E=zeros(1, vetvi);
for yy=1:vetvi
        for zz=1:nn
        sum_E (yy)=sum_E (yy)+m_element (4, yy, zz);  
                                                      
                                                      
        end
end
sum_J=zeros(1, vetvi);
kolv_J=0;
for yy=1:vetvi
        for zz=1:nn
            kolv_J1=0;
        sum_J (yy)=sum_J (yy)+m_element (5, yy, zz);  
            if m_element (5, yy, zz)~=0
                if kolv_J1==0
                    kolv_J1=1;
                end
            end
            if m_element(5, yy, zz)~=0    %если на ветви есть источник тока
    I(yy)=sum_J (yy);          %ток на ветви равен сумме токов на ист. тока
            end
        end
        if kolv_J1==1
        kolv_J=kolv_J+1;                   %кол-во ветвей, на которых есть источник тока. Понадобится для того, чтобы понять, сколько уравнений по 2 закону Кирхгофа нам нужно(не только в этом коде)
        end
end    

%сейчас буду писать контура
%сначала создам граф без источников тока, так как они не могут входить в контур
dop=zeros(1, vetvi);
graf_dlya_cont2=zeros(size(graf, 1), size(graf, 2));
for yy=1:vetvi
    for uu=1:uzli
    if sum_J(yy)==0     %здесь возможно недоработка, но если ее никто не заметит, то ее и нет
        graf_dlya_cont2(uu, yy)=graf(uu, yy);
    end
    end
end

   %из этого графа надо как-то получить матрицу контуров. Для начала нужно перевести этот граф на язык матлаба, который понимает список конечных узлов каждого ребра:
graf_dlya_cont=zeros(2, vetvi-kolv_J);
bv=1; %номер элемента (ветви) в графе для контуров первая строка
vb=1; %тоже. вторая строка
for yy=1:vetvi
for uu=1:uzli   
        if graf_dlya_cont2(uu,yy)==1
            graf_dlya_cont(1, bv)=uu;
            bv=bv+1;
        end
        if graf_dlya_cont2(uu,yy)==-1
            graf_dlya_cont(2, vb)=uu;
            vb=vb+1;
        end
    end
end
 %но нужно не забыть, что мы выкинули ветви с источником тока
%и нумерация сбилась, начиая с третьей ветви.

G1=graph(graf_dlya_cont(1, :), graf_dlya_cont(2, :)); 
%plot(graf_dlya_cont1);
[cycles,edgecycles] = cyclebasis(G1); % базис циклов и ребра в этих циклах (крутая функция)
p = plot(G1,'EdgeLabel',1:numedges(G1));
%disp(graf_dlya_cont);
disp(cycles{1});
disp(edgecycles{1});
%вся нумерация сбилась. Я не знаю, мне работать с новой нумерацией,
%используя возможности матлаба, или сопоставить ребра и узлы в начальном
%графе с ребрами и узлами в этом графе. это будет сложно
colvcont=vetvi-uzli+1-kolv_J;
contur=zeros(colvcont, vetvi);          %заготовка
%for ui=1:colvcont


%contur(colvcont, :)=
%end

%тоже входные данные (то, что должно получится)
contur1=[1, 0, 0, -1, 0, -1];          %если ток идет по котнуру, пишем 1. если против, пишем -1. если ветвь не входит в контур, пишем 0. Моя авторская "матрица инцидентности"
contur2=[0, 1, 0, -1, 1, 0];
contur=[contur1; contur2];
%конец входных данных
ur2=size((contur),1);
uravneniya2=zeros(ur2, vetvi);
pravaya=zeros(ur2, 1);
for ee=1:ur2
    for rr=1:vetvi
    uravneniya2(ee, rr)=contur(ee, rr)*sum_R (rr);             %уравнения по 2 закону Кирхгофа (левая часть) и без умножения на ток
    pravaya(ee, 1)=pravaya(ee, 1)+sum_E(rr)*contur(ee,rr);         %правая часть уравнений
    end
end

graf3=zeros(uzli-1, vetvi);
for tt=1:uzli-1
for zx=1:vetvi
graf3(tt, zx)=graf(tt,zx);                    %матрица уравнений по первому закону (без поледнего узла)
end
end

pravaya_dop=zeros(kolv_J, 1);
dop_urav2=zeros(kolv_J, vetvi);
if kolv_J~=0
for mn=1:kolv_J
for bn=1:vetvi
    for tt=1:nn
if m_element(5, bn, tt)~=0
    dop_urav2(mn,bn)=1;
end
    end
end
end
end      %создали доп уравнение (левая часть)

for kl=1:kolv_J
    lk=kl;
    for re=1:vetvi
        if sum_J(re)~=0 && pravaya_dop(kl, 1)==0 && lk==1
    pravaya_dop(kl, 1)=sum_J(re);
        end
         if sum_J(re)~=0 && pravaya_dop(kl, 1)==0
    lk=lk-1;
        end
    end
end             %так надо, не пытайтесь разобраться. Я сам забуду, как это работает через час


coef_uravneniya=[graf3; uravneniya2; dop_urav2] ;     %матрица уравнений
pravaya=[pravaya; pravaya_dop];
pravaya2=[zeros(1, uzli-1), pravaya.'].';                       %правая часть всех уравнений
I2=coef_uravneniya\pravaya2;                              
%конец. чтобы вольтметром мерять напряжение нужно подключить его к n и m
%ветвям в те части ветви, которые идут после k-того элемента по направлению
%тока. (если k=0 то подключили к первому узлу и так далее)
%затем ищем любую цепь (путь) от точек n k1 до m k2 и считаем напряжение
%(это будет сумма напряжений на элементах. это сделаем потом, когда
%разберемся с контурами
