clc;
clear variables;
%Мой метод.(я Кочетков Александр если что) Через матрицу инцидентности, описывающую цепь без элементов.
%входные данные.     Если узлов нет, то решаем другим методом
R1=200;     %задача из 3 семинара. Ответ сошелся (у меня другое направление токов, поэтому знак другой на некоторых ветвях. направление от меньшего узла к большему(по номеру))
E1=600;          
E3=100i;
C2=-100i;
L2=200i;
C4=-100i;
R5=100;
J5=-2+2i;
L6=100i;
E6=-100i;                     
a=[1 0 0 -1].';            %это матрица инцидентности для графа схемы. 
b=[1 -1 0 0].';            %не работает, если в схеме нет узлов. 
c=[0 1 0 -1].';            %тогда исмользуем закон ома
d=[1 0 -1 0].';
e=[0 1 -1 0].';
f=[0 0 1 -1].';
graf=[a b c d e f];
graf_modul=abs(graf);         %это неориентированный граф тот же самый, понадобится тоже
a1=[R1 0 0 E1 0]';             %здесь входные данные в виде просто 
% транспонированного вектора,
% но если на ветви более одного элемента одного типа, 
% то эти элементы записываются в третьей размерности
b1=[0 0 0 E3 0].';
c1=[R5 0 0 0 J5].';
d1=[0 C2 L2 0 0].';
e1=[0 C4 0 0 0].';
f1=[0 0 L6 E6 0].';
m_element=[a1 b1 c1 d1 e1 f1]; %это матрица элементов на ветвях (сейчас у нее 2 размерности, так как на ветви максимум 1 элемент одного типа)
%конец входных данных
vetvi=size(graf, 2);     %кол-во ветвей
I=zeros(1, vetvi);         %массив токов на ветвях (будущий ответ)
uzli=size(graf, 1);         %кол-во узлов
nn=size(m_element, 3);      %максимальное кол-во элементов одного типа на 
                            % ветви (третья размерность матрицы элементов)
sum_R=zeros(1, vetvi);
for yy=1:vetvi
    for xx=1:3
        for zz=1:nn
        sum_R (yy)=sum_R (yy)+m_element (xx, yy, zz); % массив сум Р теперь состоит 
                                                      % из сумм сопротивлений на ветвях от 1 до последней
        end
    end
end

sum_E=zeros(1, vetvi);
for yy=1:vetvi
        for zz=1:nn
        sum_E (yy)=sum_E (yy)+m_element (4, yy, zz);  
                                                      
                                                      
        end
end
dop_u_kolv=0;
xv=0;
sum_J=zeros(1, vetvi);
kolv_J=0;
for yy=1:vetvi
        for zz=1:nn
            kolv_J1=0;
        sum_J (yy)=sum_J (yy)+m_element (5, yy, zz);  
            if m_element (5, yy, zz)~=0
                if kolv_J1==0
                    kolv_J1=1;
                end
            end
        end
        if kolv_J1==1
        kolv_J=kolv_J+1;                   %кол-во ветвей, на которых есть источник тока. Понадобится для того, чтобы понять, сколько уравнений по 2 закону Кирхгофа нам нужно(не только в этом коде)
        end

%ищу ветви, на которых есть J (источник тока)
for tt=1:nn
if m_element(5, yy, tt)~=0    %если на ветви есть источник тока
    I(yy)=sum_J (yy);          %ток на ветви равен сумме токов на ист. тока
    if xv==0
    dop_u_kolv=dop_u_kolv+1;    %кол-во дополнительных (почти нулевых) уравнений ( кол-во ветвей, на которых есть ист. тока)
    xv=1;                       %зачем у меня две переменные, обозначающие ветви с J, я не знаю. но пусть будут, не хочу ломать код
    end
end
end
xv=0;
end           
%я пытался написать код, который из уже имеющихся данных составляет
%контуры, но не смог. Для этого нужно 1)освоить метод “поиск в глубину”
%(DFS), 2) преобразовать его для поиска циклов (я нашел вроде нормальный код, но он на С#
% 3)взять нужное кол-во циклов из них. Но брать нужно не абы какой, а только те, что удовлетворяют
%условиям, а именно: это контур независимый (в нем есть хотя бы одна ветвь,
%которая не вошла в другие котура), в нем нет источников тока (хотя можно
%изначально искать циклы в графе (схеме), из которого убрали ветви с
%источником тока) 4)учесть, что может случится так, что независимый контур
%составить невозможно (все ветви уже обошли), а кол-во контуров еще
%недостаточно. (такое может случится, я проверял).
%Я пытался написать код, но слишком много нюансов, не могу столько инфы
%усвоить. Поэтому я пока оставлю матрицу контуров в входных данных (нет, я
%не перекладываю работу на вас. Ксюша, успокойся) Вообще можно попросить
%пользователя ввести контуры, которые он хочет (но это нечестно)

%тоже входные данные
contur1=[1, 0, 0, -1, 0, -1];          %если ток идет по котнуру, пишем 1. если против, пишем -1. если ветвь не входит в контур, пишем 0. Моя авторская "матрица инцидентности"
contur2=[0, 1, 0, -1, 1, 0];
contur=[contur1; contur2];
%конец входных данных
ur2=size((contur),1);
uravneniya2=zeros(ur2, vetvi);
pravaya=zeros(ur2, 1);
for ee=1:ur2
    for rr=1:vetvi
    uravneniya2(ee, rr)=contur(ee, rr)*sum_R (rr);             %уравнения по 2 закону Кирхгофа (левая часть) и без умножения на ток
    pravaya(ee, 1)=pravaya(ee, 1)+sum_E(rr)*contur(ee,rr);         %правая часть уравнений
    end
end

graf3=zeros(uzli-1, vetvi);
for tt=1:uzli-1
for zx=1:vetvi
graf3(tt, zx)=graf(tt,zx);                    %матрица уравнений по первому закону (без поледнего узла)
end
end

pravaya_dop=zeros(1, kolv_J);
dop_urav2=zeros(dop_u_kolv, vetvi);
if dop_u_kolv~=0
for mn=1:dop_u_kolv
for bn=1:vetvi
    for tt=1:nn
if m_element(5, bn, tt)~=0
    dop_urav2(mn,bn)=1;
end
    end
end
end
end      %создали доп уравнение (левая часть)

for kl=1:kolv_J
    for re=1:vetvi
    pravaya_dop(kl)=pravaya_dop(kl)+sum_J(re);
    end
end
coef_uravneniya=[graf3; uravneniya2; dop_urav2] ;     %матрица уравнений
pravaya=[pravaya; pravaya_dop];
pravaya2=[zeros(1, uzli-1), pravaya.'].';                       %правая часть всех уравнений
I2=coef_uravneniya\pravaya2;                              
%конец. чтобы вольтметром мерять напряжение нужно подключить его к n и m
%ветвям в те части ветви, которые идут после k-того элемента по направлению
%тока. (если k=0 то подключили к первому узлу и так далее)
%затем ищем любую цепь (путь) от точек n k1 до m k2 и считаем напряжение
%(это будет сумма напряжений на на элементах. это сделаем потом, когда
%разберемся с контурами
